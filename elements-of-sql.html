<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Intro To Relational Databases</title>

</head>
<body>
<h1>Intro To Relational Databases</h1>

<p>Here's just a sampling of the many data types that SQL supports. We won't be using most of these types in this course, though.</p>

<p>The exact list of types differs from one database to another. For a full list of types, check the manual for your database, such as this one for PostgreSQL.</p>

<h2>Text and string types</h2>

<p><strong>text</strong> — a string of any length, like Python str or unicode types.</p>

<p><strong>char(n)</strong> — a string of exactly n characters.</p>

<p><strong>varchar(n)</strong> — a string of up to n characters.</p>

<h2>Numeric types</h2>

<p><strong>integer</strong> — an integer value, like Python int.</p>

<p><strong>real</strong> — a floating-point value, like Python float. Accurate up to six decimal places.</p>

<p><strong>double precision</strong> — a higher-precision floating-point value. Accurate up to 15 decimal places.</p>

<p><strong>decimal</strong> — an exact decimal value.</p>

<h2>Date and time types</h2>

<p><strong>date</strong> — a calendar date; including year, month, and day.</p>

<p><strong>time</strong> — a time of day.</p>

<p><strong>timestamp</strong> — a date and time together.</p>

<h2>Select statement</h2>

<p>The most basic form of the <strong>select</strong> statement is to select a single scalar value:</p>

<p><strong>select</strong> 2 + 2 ;</p>

<p>More usefully, we can select one or more columns from a table.  With no restrictions, this will return all rows in the table:</p>

<p><strong>select</strong> name, species <strong>from</strong> animals ;</p>

<p>Columns are separated by commas; use * to select all columns from the tables.</p>

<p>Quite often, we don't want all the data from a table.  We can restrict the rows using a variety of select clauses, listed below. There are also a wide variety of functions that can apply to columns; including aggregation functions that operate on values from several rows, such as <strong>max</strong> and <strong>count</strong>.</p>

<h2>where</h2>

<p>The where clause expresses restrictions — filtering a table for rows that follow a particular rule. where supports equalities, inequalities, and boolean operators (among other things):</p>

<ul>
<li><strong>where species = 'gorilla'</strong> — return only rows that have 'gorilla' as the value of the species column.</li>
<li><strong>where name >= 'George'</strong> — return only rows where the name column is alphabetically after 'George'.</li>
<li><strong>where species != 'gorilla' and name != 'George'</strong> — return only rows where species isn't 'gorilla' and name isn't 'George'.</li>
</ul>


<h2>limit / offset</h2>

<p>The <strong>limit</strong> clause sets a limit on how many rows to return in the result table. The optional offset clause says how far to skip ahead into the results. So <strong>limit 10 offset 100</strong> will return 10 results starting with the 101st.</p>

<h2>order by</h2>

<p>The <strong>order by</strong> clause tells the database how to sort the results — usually according to one or more columns. So order by <strong>species</strong>, <strong>name</strong> says to sort results first by the species column, then by name within each species.</p>

<p>Ordering happens before limit/offset, so you can use them together to extract pages of alphabetized results. (Think of the pages of a dictionary.)</p>

<p>The optional <strong>desc</strong> modifier tells the database to order results in descending order — for instance from large numbers to small ones, or from Z to A.</p>

<h2>group by</h2>

<p>The <strong>group by</strong> clause is only used with aggregations, such as <strong>max</strong> or <strong>sum</strong>. Without a <strong>group by</strong> clause, a select statement with an aggregation will aggregate over the whole selected table(s), returning only one row. With a <strong>group by</strong> clause, it will return one row for each distinct value of the column or expression in the group by clause.</p>

<h2>having</h2>

<p>The <strong>having</strong> clause works like the <strong>where</strong> clause, but it applies after <strong>group by</strong> aggregations take place. The syntax is like this:</p>

<p><strong>select</strong> columns <strong>from</strong> tables <strong>group by</strong> column <strong>having</strong> condition ;</p>

<p>Usually, at least one of the columns will be an aggregate function such as <strong>count</strong>, <strong>max</strong>, or <strong>sum</strong> on one of the tables' columns. In order to apply <strong>having</strong> to an aggregated column, you'll want to give it a name using <strong>as</strong>. For instance, if you had a table of items sold in a store, and you wanted to find all the items that have sold more than five units, you could use:</p>

<p><strong>select name, count(*) as num from sales having num > 5;</strong></p>

<p>You can have a <strong>select</strong> statement that uses only <strong>where</strong>, or only <strong>group by</strong>, or <strong>group by</strong> and <strong>having</strong>, or <strong>where</strong> and <strong>group by</strong>, or all three of them!</p>

<p>But it doesn't usually make sense to use having without group by.</p>

<p>If you use both <strong>where</strong> and <strong>having</strong>, the <strong>where</strong> condition will filter the rows that are going into the aggregation, and the <strong>having</strong> condition will filter the rows that come out of it.</p>

<p>You can read more about <strong>having</strong> here:</p>

<p><a href="http://www.postgresql.org/docs/9.4/static/sql-select.html#SQL-HAVING">http://www.postgresql.org/docs/9.4/static/sql-select.html#SQL-HAVING</a></p>

<p><img src="img\select-where.png" alt="" /></p>

<p>By default, SQL statements are terminated with semicolons. You use a semicolon to terminate statements unless you've (rarely) set a new statement terminator.</p>

<p>The big difference between comparison operators in SQL and in Python is that we use = for equality in SQL, whereas Python uses ==.</p>

<pre><code>select name from animals where species != 'gorilla' and name != 'Max';
</code></pre>

<pre><code>Find all the llamas born between January 1, 1995 and December 31, 1998.

select 
    name 
from 
    animals 
where 
    species = 'llama' and 
    birthdate &gt;= '1995-01-01' and 
    birthdate &lt;= '1998-12-31'
</code></pre>

<p><img src="img/list-tables-and-columns.png" alt="" /></p>

<h2>All the tables in the zoo database</h2>

<h3>animals</h3>

<p>This table lists individual animals in the zoo. Each animal has only one row. There may be multiple animals with the same name, or even multiple animals with the same name and species.</p>

<ul>
<li>name — the animal's name (example: 'George')</li>
<li>species — the animal's species (example: 'gorilla')</li>
<li>birthdate — the animal's date of birth (example: '1998-05-18')</li>
</ul>


<h3>diet</h3>

<p>This table matches up species with the foods they eat. Every species in the zoo eats at least one sort of food, and many eat more than one. If a species eats more than one food, there will be more than one row for that species.</p>

<ul>
<li>species — the name of a species (example: 'hyena')</li>
<li>food — the name of a food that species eats (example: 'meat')</li>
</ul>


<h3>taxonomy</h3>

<p>This table gives the (partial) biological taxonomic names for each species in the zoo. It can be used to find which species are more closely related to each other evolutionarily.</p>

<ul>
<li>name — the common name of the species (e.g. 'jackal')</li>
<li>species — the taxonomic species name (e.g. 'aureus')</li>
<li>genus — the taxonomic genus name (e.g. 'Canis')</li>
<li>family — the taxonomic family name (e.g. 'Canidae')</li>
<li>t_order — the taxonomic order name (e.g. 'Carnivora')</li>
</ul>


<p>If you've never heard of this classification, don't worry about it; the details won't be necessary for this course. But if you're curious, Wikipedia articles Taxonomy and Biological classification may help.</p>

<h3>ordernames</h3>

<p>This table gives the common names for each of the taxonomic orders in the taxonomy table.</p>

<ul>
<li>t_order — the taxonomic order name (e.g. 'Cetacea')</li>
<li>name — the common name (e.g. 'whales and dolphins')</li>
</ul>


<h3>The SQL for it</h3>

<p>And here are the SQL commands that were used to create those tables. We won't cover the create table command until lesson 4, but it may be interesting to look at:</p>

<pre><code>create table animals (  
       name text,
       species text,
       birthdate date);

create table diet (
       species text,
       food text);  

create table taxonomy (
       name text,
       species text,
       genus text,
       family text,
       t_order text); 

create table ordernames (
       t_order text,
       name text);
</code></pre>

<p>Remember: In SQL, we always put string and date values inside single quotes.</p>

<h3>Sample Queries</h3>

<pre><code>select max(name) from animals;
+-----------+
| max(name) |
+===========+
|       Zoe |
+-----------+

select * from animals limit 10;
+----------+------------+------------+
|     name |    species |  birthdate |
+==========+============+============+
|   Andrea |     alpaca | 2001-01-16 |
|    Bruno |     alpaca | 2004-09-23 |
|  Charlie |     alpaca | 2004-09-23 |
|    Della |     alpaca | 2006-01-09 |
|     Emma |     alpaca | 2013-03-16 |
|     Fred | brown bear | 1993-05-02 |
|   George | brown bear | 1997-06-24 |
|    Molly | brown bear | 1981-10-17 |
|  Eliezer |      camel | 1971-03-08 |
| Giuseppe |      camel | 1979-12-25 |
+----------+------------+------------+

select * from animals where species = 'orangutan' order by birthdate;
+---------+-----------+------------+
|    name |   species |  birthdate |
+=========+===========+============+
|    Raja | orangutan | 1975-04-09 |
| Kambing | orangutan | 1988-11-12 |
|    Ratu | orangutan | 1989-09-15 |
|  Putera | orangutan | 1993-06-29 |
|   Gajah | orangutan | 2011-05-26 |
|   Singa | orangutan | 2012-11-03 |
+---------+-----------+------------+

select name from animals where species = 'orangutan' order by birthdate desc;
+---------+
|    name |
+=========+
|   Singa |
|   Gajah |
|  Putera |
|    Ratu |
| Kambing |
|    Raja |
+---------+

select name, birthdate from animals order by name limit 10 offset 20;
+---------+------------+
|    name |  birthdate |
+=========+============+
|   Duran | 2009-09-20 |
| Ekwensu | 1993-10-31 |
|     Eli | 2002-02-22 |
| Eliezer | 1971-03-08 |
|    Emma | 2013-03-16 |
|    Emmy | 2008-04-15 |
|    Fido | 1999-08-04 |
| Francis | 1996-04-27 |
|    Fred | 1993-05-02 |
|   Gajah | 2011-05-26 |
+---------+------------+

select species, min(birthdate) from animals group by species;
+------------+----------------+
|    species | min(birthdate) |
+============+================+
|     alpaca |     2001-01-16 |
| brown bear |     1981-10-17 |
|      camel |     1971-03-08 |
|      dingo |     1999-08-04 |
|    echidna |     2003-01-31 |
|     ferret |     2006-09-18 |
|    gorilla |     1979-07-04 |
|      hyena |     2007-06-08 |
|     iguana |     1999-09-09 |
|     jackal |     2003-12-21 |
|      llama |     1984-01-05 |
|   mongoose |     2006-02-28 |
|      moose |     1990-03-27 |
|    narwhal |     1975-02-07 |
|  orangutan |     1975-04-09 |
|   platypus |     2000-04-13 |
|    raccoon |     2009-08-11 |
|   sea lion |     1987-04-29 |
|    unicorn |     1752-05-20 |
|    warthog |     2007-05-20 |
|        yak |     1996-09-20 |
|      zebra |     1989-03-15 |
+------------+----------------+

select name, count(*) as num from animals
group by name
order by num desc
limit 5;
+---------+-----+
|    name | num |
+=========+=====+
|  George |   4 |
|  Andrea |   2 |
| Charlie |   2 |
|    John |   2 |
|     Max |   2 |
+---------+-----+

select species, count(*) as count from animals
group by species
order by count desc
limit 1;
+---------+-------+
| species | count |
+=========+=======+
| gorilla |     9 |
+---------+-------+
</code></pre>

<p><img src="img/select-clause1.png" alt="" />
<img src="img/select-clause2.png" alt="" />
<img src="img/count-species.png" alt="" /></p>

<h2>insert</h2>

<p>The basic syntax for the <strong>insert</strong> statement:</p>

<p><strong>insert into</strong> table ( column1, column2, ... ) <strong>values</strong> ( val1, val2, ... );</p>

<p>If the values are in the same order as the table's columns (starting with the first column), you don't have to specify the columns in the <strong>insert</strong> statement:</p>

<p><strong>insert into</strong> table <strong>values</strong> ( val1, val2, ... );</p>

<pre><code>insert into animals values ('Bitey', 'opossum', '2015-04-08');
</code></pre>

<p>For instance, if a table has three columns <strong>(a, b, c)</strong> and you want to insert into <strong>a</strong> and <strong>b</strong>, you can leave off the column names from the insert statement. But if you want to insert into <strong>b</strong> and <strong>c</strong>, or <strong>a</strong> and <strong>c</strong>, you have to specify the columns.</p>

<p>A single <strong>insert</strong> statement can only insert into a single table. (Contrast this with the <strong>select</strong> statement, which can pull data from several tables using a join.)</p>

<p><img src="img/insert.png" alt="" /></p>

<h2>join</h2>

<p><img src="img/join.png" alt="" /></p>

<pre><code>select animals.name
from animals join diet
on animals.species = diet.species
where food = 'fish'
+---------+
|    name |
+=========+
|    Fred |
|  George |
|   Molly |
|   Bacon |
| Francis |
|   Inara |
|     Mal |
|   River |
|   Simon |
|     Zoe |
+---------+
select 
    name 
from 
    animals, diet
where 
    animals.species = diet.species
    and
    diet.food = 'fish'
</code></pre>

<p>columns that are used in join doesn't have to be in select</p>

<h2>After Aggregating</h2>

<p><img src="img/after_aggregating_wrong.png" alt="" />
<img src="img/after_aggregating_correct.png" alt="" /></p>

<pre><code>Find the one food that is eaten by only one animal.

select 
    diet.food, count(animals.name) as num
from 
    diet, animals
where
    diet.species = animals.species
group by
    diet.food
having
    num = 1
+--------+-----+
|   food | num |
+========+=====+
| snakes |   1 |
+--------+-----+
</code></pre>

<h2>More Join Practice</h2>

<pre><code>select 
    ordernames.name, count(animals.name) as num
from
    ordernames, taxonomy, animals
where
    ordernames.t_order = taxonomy.t_order
    and
    taxonomy.name = animals.species
group by
    ordernames.name
order by
    num desc
+---------------------+-----+
|                name | num |
+=====================+=====+
| even-toed ungulates |  29 |
|          carnivores |  25 |
|            primates |  15 |
|  odd-toed ungulates |   7 |
|  lizards and snakes |   4 |
|          monotremes |   4 |
|          marsupials |   3 |
| whales and dolphins |   2 |
+---------------------+-----+
</code></pre>

<p>Here's one possible solution:</p>

<pre><code>select ordernames.name, count(*) as num
  from animals, taxonomy, ordernames
  where animals.species = taxonomy.name
    and taxonomy.t_order = ordernames.t_order
  group by ordernames.name
  order by num desc
</code></pre>

<p>And here's another, this time using the explicit join style:</p>

<pre><code>select ordernames.name, count(*) as num
  from (animals join taxonomy 
                on animals.species = taxonomy.name)
                as ani_tax
        join ordernames
             on ani_tax.t_order = ordernames.t_order
  group by ordernames.name
  order by num desc
</code></pre>

<p>I think the upper version is much more readable than the lower one, because in the explicit join style you have to explicitly tell the database what order to join the tables in — <code>((a join b) join c)</code> — instead of just letting the database worry about that.</p>

<p>If you're using a more barebones database (like SQLite) there can be a performance benefit to the explicit join style. But in PostgreSQL, the more server-oriented database system we'll be using next lesson, the query planner should optimize away any difference.</p>
</body>
</html>